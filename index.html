<!DOCTYPE html>

<html>
<head>
  <title>Hyakko</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
      <link rel="stylesheet" media="all" href="hyakko.css" />
    </head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
                <h1 id="hyakko">Hyakko</h1>
        
              </div>

<p><strong>Hyakko</strong> is a Haskell port of <a href="http://jashkenas.github.com/docco/">docco</a>: the original quick-and-dirty documentation generate. It produces an HTML document that displays your comments intermingled with you code. All prose is passed through <a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a>, and code is passed through <a href="http://johnmacfarlane.net/highlighting-kate/">Kate</a> syntax highlighing. This page is the result of running Hyakko against its own <a href="https://github.com/sourrust/hyakko/blob/master/src/Hyakko.lhs">source file</a>.</p>
<ol style="list-style-type: decimal">
<li><p>Install Hyakko with <strong>cabal</strong>: <code>cabal update; cabal install hyakko</code></p></li>
<li><p>Run it agianst your code: <code>hyakko src/*.hs</code> or just <code>hyakko src</code> and Hyakko will search for supported files inside the directory recursively.</p></li>
</ol>
<p>There is no &quot;Step 3&quot;. This will generate an HTML page for each of the named source files, with a menu linking to the other pages, saving the whole mess into a <code>docs</code> folder — and is also configurable.</p>
<p>The <a href="https://github.com/sourrust/hyakko">Hyakko source</a> is available on GitHub, and is released under the <a href="http://opensource.org/licenses/MIT">MIT license</a>.</p>
<p>There is a <a href="http://www.haskell.org/haskellwiki/Literate_programming">&quot;literate&quot; style</a> of Haskell, only one supported at this time, but other literate styles can be added fairly easily via a <a href="https://github.com/sourrust/hyakko/blob/master/resources/languages.json">separate languages file</a>.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Hyakko.Text.Markdown
<span class="kw">import</span> Hyakko.Text.Templates
<span class="kw">import</span> Hyakko.Types

<span class="kw">import</span> Data.Aeson (decode&#39;)
<span class="kw">import</span> <span class="kw">qualified</span> Data.HashMap.Strict <span class="kw">as</span> M
<span class="kw">import</span> Data.ByteString.Lazy.Char8 (ByteString)
<span class="kw">import</span> <span class="kw">qualified</span> Data.ByteString.Lazy.Char8 <span class="kw">as</span> L
<span class="kw">import</span> Data.Text (Text)
<span class="kw">import</span> <span class="kw">qualified</span> Data.Text <span class="kw">as</span> T
<span class="kw">import</span> <span class="kw">qualified</span> Data.Text.IO <span class="kw">as</span> T
<span class="kw">import</span> Data.List (sort)
<span class="kw">import</span> Data.Maybe (fromJust, isNothing)
<span class="kw">import</span> Data.Version (showVersion)
<span class="kw">import</span> Control.Applicative ((&lt;$&gt;))
<span class="kw">import</span> Control.Monad (filterM, (&gt;=&gt;), forM, forM_, unless, when)
<span class="kw">import</span> Control.Monad.State.Strict
<span class="kw">import</span> <span class="kw">qualified</span> Text.Blaze.Html <span class="kw">as</span> B
<span class="kw">import</span> Text.Blaze.Html.Renderer.Utf8 (renderHtml)
<span class="kw">import</span> <span class="kw">qualified</span> Text.Highlighting.Kate <span class="kw">as</span> K
<span class="kw">import</span> Text.Pandoc.Templates
<span class="kw">import</span> Text.Regex.PCRE ((=~))
<span class="kw">import</span> System.Console.CmdArgs
<span class="kw">import</span> System.Directory ( getDirectoryContents
                        , doesDirectoryExist
                        , doesFileExist
                        , createDirectoryIfMissing
                        , copyFile
                        )
<span class="kw">import</span> System.IO.Unsafe (unsafePerformIO)
<span class="kw">import</span> System.FilePath ( takeBaseName
                       , takeExtension
                       , takeFileName
                       , (<span class="fu">&lt;/&gt;</span>)
                       , addTrailingPathSeparator
                       )
<span class="kw">import</span> Paths_hyakko (getDataFileName, version, getDataDir)
</code></pre>
<h2 id="main-documentation-generation-functions">Main Documentation Generation Functions</h2>
<p>Generate the documentation for our configured source file by copyinh over static assets, reading all the source files in, splitting them up into prose+code sections, highlighting each file in the approapiate language, and printing them out in an HTML template.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">generateDocumentation ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> [<span class="fu">FilePath</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
generateDocumentation _ [] <span class="fu">=</span>
  <span class="fu">putStrLn</span> <span class="st">&quot;hyakko: no files or options given (try --help)&quot;</span>
generateDocumentation opts xs <span class="fu">=</span> <span class="kw">do</span>
  dataDir <span class="ot">&lt;-</span> getDataDir
  <span class="kw">let</span> opts&#39;  <span class="fu">=</span> configHyakko opts dataDir
      dirout <span class="fu">=</span> output opts&#39;
  style <span class="ot">&lt;-</span> hyakkoStyles opts&#39;
  T.writeFile (dirout <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.css&quot;</span>) style
  unless (isNothing <span class="fu">$</span> layout opts&#39;) <span class="fu">$</span> <span class="kw">do</span>
    <span class="kw">let</span> layoutDir <span class="fu">=</span> fromJust <span class="fu">$</span> layout opts&#39;
    copyDirectory opts&#39; <span class="fu">$</span> dataDir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;resources&quot;</span> <span class="fu">&lt;/&gt;</span> layoutDir
                                  <span class="fu">&lt;/&gt;</span> <span class="st">&quot;public&quot;</span>
  forM_ xs <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
    code <span class="ot">&lt;-</span> T.readFile x
    <span class="kw">let</span> sections  <span class="fu">=</span> parse (getLanguage x) code
        noSects   <span class="fu">=</span> <span class="fu">null</span> sections
    when noSects <span class="fu">$</span>
      <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot;hyakko doesn&#39;t support the language extension &quot;</span>
               <span class="fu">++</span> takeExtension x
    unless noSects <span class="fu">$</span> <span class="kw">do</span>
      <span class="kw">let</span> highlighted <span class="fu">=</span> highlight x sections
          y           <span class="fu">=</span> mapSections sections highlighted
      generateHTML opts&#39; x y
</code></pre>
<p>Given a string of source code, parse out eacg block of prose and the code that follows it — by detecting which is which, line by line — then create an individual <strong>section</strong> for it. Each section is Map with <code>docText</code> and <code>codeText</code> properties, and eventuall <code>docsHtml</code> and <code>codeHtml</code> as well.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">inSections ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Sections</span>
inSections xs r <span class="fu">=</span>
  <span class="kw">let</span> sections <span class="fu">=</span> sectionOff <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span> xs
  <span class="kw">in</span> <span class="fu">map</span> M.fromList sections

  <span class="kw">where</span><span class="ot"> save ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">Text</span>)]
        save code docs <span class="fu">=</span> [ (<span class="st">&quot;codeText&quot;</span>, code)
                         , (<span class="st">&quot;docsText&quot;</span>, docs)
                         ]

<span class="ot">        sectionOff ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> [[(<span class="dt">String</span>, <span class="dt">Text</span>)]]
        sectionOff code docs [] <span class="fu">=</span> save code docs <span class="fu">:</span> []
        sectionOff code docs (y<span class="fu">:</span>ys) <span class="fu">=</span>
          <span class="kw">let</span> line    <span class="fu">=</span> T.unpack y
              shebang <span class="fu">=</span> L.pack <span class="st">&quot;(^#![/]|^\\s*#\\{)&quot;</span>
          <span class="kw">in</span> <span class="kw">if</span> line <span class="fu">=~</span> r <span class="fu">&amp;&amp;</span> (<span class="fu">not</span> <span class="fu">$</span> line <span class="fu">=~</span> shebang) <span class="kw">then</span>
               handleDocs code
               <span class="kw">else</span>
                 sectionOff (code <span class="fu">++.</span> y <span class="fu">++.</span> <span class="st">&quot;\n&quot;</span>) docs ys

          <span class="kw">where</span> handleDocs <span class="st">&quot;&quot;</span> <span class="fu">=</span> handleHeaders code (newdocs docs) ys
                handleDocs _  <span class="fu">=</span> save code docs
                              <span class="fu">:</span> handleHeaders <span class="st">&quot;&quot;</span> (newdocs <span class="st">&quot;&quot;</span>) ys

                newdocs d <span class="fu">=</span> d <span class="fu">++.</span> (replace r y <span class="st">&quot;&quot;</span>) <span class="fu">++.</span> <span class="st">&quot;\n&quot;</span>
</code></pre>
<p>If there is a header markup, only for <code>---</code> and <code>===</code>, it will get its own line from the other documentation.</p><pre class="sourceCode"><code class="sourceCode">                handleHeaders c d zs <span class="fu">=</span>
                  <span class="kw">if</span> T.unpack d <span class="fu">=~</span> L.pack <span class="st">&quot;^(---|===)+&quot;</span> <span class="kw">then</span>
                    save c d <span class="fu">:</span> sectionOff <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span> zs
                    <span class="kw">else</span>
                      sectionOff c d zs
</code></pre>
<p>The higher level interface for calling <code>inSections</code>. <code>parse</code> basically sanitates the file — turing literate into regular source and take out shebangs — then feed it to <code>inSections</code>, and finally return the results.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">parse ::</span> <span class="dt">Maybe</span> <span class="dt">Language</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Sections</span>
parse <span class="kw">Nothing</span> _       <span class="fu">=</span> []
parse (<span class="kw">Just</span> src) code <span class="fu">=</span>
  inSections (fromLiterate (T.lines code) <span class="fu">$</span> literate src)
             (<span class="st">&quot;^\\s*&quot;</span> <span class="fu">++*</span> symbol src <span class="fu">++*</span> <span class="st">&quot;\\s?&quot;</span>)
</code></pre>
<p>Transforms a literate style language file into its normal, non-literate style language. If it is normal, <code>fromLiterate</code> for returns the same list of <code>Text</code> that was passed in.</p><pre class="sourceCode"><code class="sourceCode">  <span class="kw">where</span><span class="ot"> fromLiterate ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>]
        fromLiterate [] _       <span class="fu">=</span> []
        fromLiterate xs <span class="kw">Nothing</span> <span class="fu">=</span> xs
        fromLiterate xs _       <span class="fu">=</span>
          <span class="kw">let</span> s  <span class="fu">=</span> T.pack <span class="fu">.</span> L.unpack <span class="fu">$</span> symbol src
              r  <span class="fu">=</span> <span class="st">&quot;^&quot;</span> <span class="fu">++*</span> (fromJust <span class="fu">$</span> litSymbol src) <span class="fu">++*</span> <span class="st">&quot;\\s?&quot;</span>
              r1 <span class="fu">=</span> L.pack <span class="st">&quot;^\\s*$&quot;</span>
              fn <span class="fu">=</span> forM xs <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
                (ys, isText) <span class="ot">&lt;-</span> get
                <span class="kw">let</span> hasLitSymbol <span class="fu">=</span> T.unpack x <span class="fu">=~</span> r

                when hasLitSymbol <span class="fu">$</span>
                  put (ys <span class="fu">++</span> [replace r x <span class="st">&quot;&quot;</span>], <span class="kw">False</span>)
</code></pre>
<p>Inserts a comment symbol and a single space into the documentation line and check if the last line was code and documentation. If the previous line was code and the line is blank or has just whitespace, it returns a blank <code>Text</code> datatype; otherwise it will return just the comment symbol.</p><pre class="sourceCode"><code class="sourceCode">                unless hasLitSymbol <span class="fu">$</span>
                  <span class="kw">case</span> (T.unpack x <span class="fu">=~</span> r1, isText) <span class="kw">of</span>
                    (<span class="kw">True</span>, <span class="kw">True</span>)  <span class="ot">-&gt;</span> put (ys <span class="fu">++</span> [s], <span class="kw">True</span>)
                    (<span class="kw">True</span>, <span class="kw">False</span>) <span class="ot">-&gt;</span> put (ys <span class="fu">++</span> [T.empty], <span class="kw">False</span>)
                    (<span class="kw">False</span>, _)    <span class="ot">-&gt;</span> put (ys <span class="fu">++</span> [s <span class="fu">++.</span> <span class="st">&quot; &quot;</span> <span class="fu">++.</span> x], <span class="kw">True</span>)
          <span class="kw">in</span> <span class="fu">fst</span> <span class="fu">.</span> <span class="fu">snd</span> <span class="fu">$</span> runState fn ([], <span class="kw">True</span>)
</code></pre>
<p>Highlights the current file of code, using <strong>Kate</strong>, and outputs the the highlighted html to its caller.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">highlight ::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Sections</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>]
highlight src section <span class="fu">=</span>
  <span class="kw">let</span> language <span class="fu">=</span> fromJust <span class="fu">$</span> getLanguage src
      langName <span class="fu">=</span> L.unpack <span class="fu">$</span> name_ language
      input    <span class="fu">=</span> <span class="fu">map</span> (T.unpack <span class="fu">.</span> (<span class="fu">M.!</span> <span class="st">&quot;codeText&quot;</span>)) section
      html     <span class="fu">=</span> B.toHtml <span class="fu">.</span> K.formatHtmlBlock K.defaultFormatOpts
                          <span class="fu">.</span> K.highlightAs langName
      htmlText <span class="fu">=</span> T.pack <span class="fu">.</span> L.unpack <span class="fu">.</span> renderHtml <span class="fu">.</span> html
  <span class="kw">in</span> <span class="fu">map</span> htmlText input
</code></pre>
<p><code>mapSections</code> is used to insert the html parts of the mapped sections of text into the corresponding keys of <code>docsHtml</code> and <code>codeHtml</code>.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">mapSections ::</span> <span class="dt">Sections</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Sections</span>
mapSections section highlighted <span class="fu">=</span>
  <span class="kw">let</span> docText s  <span class="fu">=</span> toHTML <span class="fu">.</span> T.unpack <span class="fu">$</span> s <span class="fu">M.!</span> <span class="st">&quot;docsText&quot;</span>
      codeText i <span class="fu">=</span> highlighted <span class="fu">!!</span> i
      sectLength <span class="fu">=</span> (<span class="fu">length</span> section) <span class="fu">-</span> <span class="dv">1</span>
      intoMap x  <span class="fu">=</span> <span class="kw">let</span> sect <span class="fu">=</span> section <span class="fu">!!</span> x
                   <span class="kw">in</span> M.insert <span class="st">&quot;docsHtml&quot;</span> (docText sect) <span class="fu">$</span>
                      M.insert <span class="st">&quot;codeHtml&quot;</span> (codeText x) sect
  <span class="kw">in</span> <span class="fu">map</span> intoMap [<span class="dv">0</span> <span class="fu">..</span> sectLength]
</code></pre>
<p>Once all of the code is finished highlighting, we can generate the HTML file and write out the documentation. Pass the completed sections into the template found in <code>resources/linear/hyakko.html</code> or <code>resources/parallel/hyakko.html</code>.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">generateHTML ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Sections</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
generateHTML opts src section <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> title       <span class="fu">=</span> takeFileName src
      dest        <span class="fu">=</span> destination (output opts) src
      maybeLayout <span class="fu">=</span> layout opts
      header      <span class="fu">=</span> T.unpack <span class="fu">$</span> (section <span class="fu">!!</span> <span class="dv">0</span>) <span class="fu">M.!</span> <span class="st">&quot;docsHtml&quot;</span>
      isHeader    <span class="fu">=</span> header <span class="fu">=~</span> L.pack <span class="st">&quot;^&lt;(h\\d)&quot;</span>
      count       <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> (<span class="fu">length</span> section) <span class="fu">-</span> <span class="dv">1</span>]
      (h, count&#39;) <span class="fu">=</span> <span class="kw">if</span> isHeader <span class="kw">then</span>
        <span class="kw">let</span> layout&#39; <span class="fu">=</span> <span class="kw">if</span> isNothing maybeLayout <span class="kw">then</span> <span class="st">&quot;&quot;</span>
                      <span class="kw">else</span> fromJust maybeLayout
        <span class="kw">in</span> ( [(<span class="st">&quot;header&quot;</span>, header)]
           , (<span class="kw">if</span> layout&#39; <span class="fu">==</span> <span class="st">&quot;linear&quot;</span> <span class="kw">then</span> <span class="fu">tail</span> <span class="kw">else</span> <span class="fu">id</span>) count)
        <span class="kw">else</span>
          ([(<span class="st">&quot;header&quot;</span>, header)], count)
  source <span class="ot">&lt;-</span> sources <span class="fu">$</span> dirOrFiles opts
  html <span class="ot">&lt;-</span> hyakkoTemplate opts <span class="fu">$</span> <span class="fu">concat</span>
    [ [(<span class="st">&quot;title&quot;</span>, <span class="kw">if</span> isHeader <span class="kw">then</span> getHeader header <span class="kw">else</span> title)]
    , h
    , cssTemplate opts
    , multiTemplate <span class="fu">$</span> <span class="fu">length</span> source
    , sourceTemplate opts source
    , sectionTemplate section maybeLayout count&#39;
    ]
  <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot;hyakko: &quot;</span> <span class="fu">++</span> src <span class="fu">++</span> <span class="st">&quot; -&gt; &quot;</span> <span class="fu">++</span> dest
  T.writeFile dest html
</code></pre>
<p>Small helper to yank out the header text from an html string, if there is a header at the top of the file.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">getHeader ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getHeader htmlheader <span class="fu">=</span>
  <span class="kw">let</span> reg            <span class="fu">=</span> L.pack <span class="st">&quot;&gt;(.+)&lt;/h\\d&gt;&quot;</span>
      [(_<span class="fu">:</span>header<span class="fu">:</span>_)] <span class="fu">=</span> htmlheader <span class="fu">=~</span> reg
  <span class="kw">in</span> header
</code></pre>
<h2 id="helpers-setup">Helpers &amp; Setup</h2>
<p>Infix functions for easier concatenation with Text and ByteString.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">(++.) ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>
(<span class="fu">++.</span>) <span class="fu">=</span> T.append
<span class="ot">{-# INLINE (++.) #-}</span>

<span class="ot">(++*) ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
(<span class="fu">++*</span>) <span class="fu">=</span> L.append
<span class="ot">{-# INLINE (++*) #-}</span>
</code></pre>
<p>Simpler type signatuted regex replace function.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">replace ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>
replace reg x y <span class="fu">=</span>
  <span class="kw">let</span> str  <span class="fu">=</span> T.unpack x
      (_, _, rp) <span class="fu">=</span> str <span class="fu">=~</span><span class="ot"> reg ::</span> (<span class="dt">String</span>, <span class="dt">String</span>, <span class="dt">String</span>)
  <span class="kw">in</span> y <span class="fu">++.</span> (T.pack rp)

<span class="ot">readLanguageFile ::</span> <span class="dt">IO</span> <span class="dt">ByteString</span>
readLanguageFile <span class="fu">=</span> getDataFileName <span class="st">&quot;resources/languages.json&quot;</span>
               <span class="fu">&gt;&gt;=</span> L.readFile
</code></pre>
<p>A list of the languages that Hyakko supports, mapping the file extension to the name of the Pygments lexer and the symbol that indicates a comment. To add another language to Hyakko's repertoire, add it here.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">languages ::</span> <span class="dt">Languages</span>
languages <span class="fu">=</span>
  <span class="kw">let</span> content  <span class="fu">=</span> unsafePerformIO <span class="fu">$</span> readLanguageFile
      jsonData <span class="fu">=</span> decode&#39; content
  <span class="kw">in</span> fromJust jsonData
</code></pre>
<p>Get the current language we're documenting, based on the extension.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">getLanguage ::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Language</span>
getLanguage src <span class="fu">=</span> M.lookup (takeExtension src) languages
</code></pre>
<p>Compute the destination HTML path for an input source file path. If the source is <code>lib/example.hs</code>, the HTML will be at docs/example.html</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">destination ::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="fu">FilePath</span>
destination out fp <span class="fu">=</span> out <span class="fu">&lt;/&gt;</span> (takeBaseName fp) <span class="fu">++</span> <span class="st">&quot;.html&quot;</span>
</code></pre>
<p>The function <code>hyakkoFile</code>, used to grab the contents of either the default css and html or a custom css and html. Then move it to the output directory.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">hyakkoFile ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
hyakkoFile filetype opts <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> maybeFile <span class="fu">=</span> (<span class="kw">if</span> filetype <span class="fu">==</span> <span class="st">&quot;css&quot;</span> <span class="kw">then</span> css <span class="kw">else</span> template) opts
  <span class="kw">if</span> isNothing maybeFile <span class="kw">then</span>
    readDataFile <span class="fu">$</span> <span class="st">&quot;resources&quot;</span>
               <span class="fu">&lt;/&gt;</span> (fromJust <span class="fu">$</span> layout opts)
               <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.&quot;</span> <span class="fu">++</span> filetype
    <span class="kw">else</span>
      T.readFile <span class="fu">$</span> fromJust maybeFile

</code></pre>
<p>Create the template that we will use to generate the Hyakko HTML page.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">hyakkoTemplate ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">String</span>)] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
hyakkoTemplate opts var <span class="fu">=</span> <span class="kw">do</span>
  content <span class="ot">&lt;-</span> hyakkoFile <span class="st">&quot;html&quot;</span> opts
  <span class="fu">return</span> <span class="fu">.</span> T.pack <span class="fu">.</span> renderTemplate var <span class="fu">$</span> T.unpack content
</code></pre>
<p>The CSS styles we'd like to apply to the documentation.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">hyakkoStyles ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
hyakkoStyles <span class="fu">=</span> hyakkoFile <span class="st">&quot;css&quot;</span>
</code></pre>
<p>Reads from resource path given in cabal package</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">readDataFile ::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
readDataFile <span class="fu">=</span> getDataFileName <span class="fu">&gt;=&gt;</span> T.readFile
</code></pre>
<p>For each source file passed in as an argument, generate the documentation.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">sources ::</span> [<span class="fu">FilePath</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="fu">FilePath</span>]
sources file <span class="fu">=</span> <span class="kw">do</span>
  files <span class="ot">&lt;-</span> forM file <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
    isDir <span class="ot">&lt;-</span> doesDirectoryExist x
    <span class="kw">if</span> isDir <span class="kw">then</span>
      <span class="fu">fst</span> <span class="fu">&lt;$&gt;</span> unpackDirectories x
      <span class="kw">else</span>
        <span class="fu">return</span> [x]
  <span class="fu">return</span> <span class="fu">.</span> <span class="fu">sort</span> <span class="fu">$</span> <span class="fu">concat</span> files
</code></pre>
<p>Turns the directory give into a list of files including all of the files in sub-directories.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">unpackDirectories ::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ([<span class="fu">FilePath</span>], [<span class="fu">FilePath</span>])
unpackDirectories d <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> reg <span class="fu">=</span> L.pack <span class="st">&quot;[^(^\\.{1,2}$)]&quot;</span>
  content <span class="ot">&lt;-</span>  <span class="fu">filter</span> (<span class="fu">=~</span> reg) <span class="fu">&lt;$&gt;</span> getDirectoryContents d
  <span class="kw">let</span> content&#39; <span class="fu">=</span> <span class="fu">map</span> (d <span class="fu">&lt;/&gt;</span>) content
  files <span class="ot">&lt;-</span> filterM doesFileExist content&#39;
  subdir <span class="ot">&lt;-</span> filterM doesDirectoryExist content&#39;
  subcontent <span class="ot">&lt;-</span> <span class="fu">fmap</span> (\x <span class="ot">-&gt;</span> (<span class="fu">concatMap</span> <span class="fu">fst</span> x, <span class="fu">concatMap</span> <span class="fu">snd</span> x))
                     (<span class="fu">mapM</span> unpackDirectories subdir)
  <span class="fu">return</span> (files <span class="fu">++</span> <span class="fu">fst</span> subcontent, subdir <span class="fu">++</span> <span class="fu">snd</span> subcontent)

<span class="ot">copyDirectory ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
copyDirectory opts dir <span class="fu">=</span> <span class="kw">do</span>
  (files, dirs) <span class="ot">&lt;-</span> unpackDirectories dir
  dataDir       <span class="ot">&lt;-</span> getDataDir
  <span class="kw">let</span> oldLocation <span class="fu">=</span> T.pack <span class="fu">.</span> addTrailingPathSeparator <span class="fu">$</span> dataDir
                      <span class="fu">&lt;/&gt;</span> <span class="st">&quot;resources&quot;</span>
                      <span class="fu">&lt;/&gt;</span> (fromJust <span class="fu">$</span> layout opts)
      dirout      <span class="fu">=</span> output opts
  createDirectoryIfMissing <span class="kw">False</span> <span class="fu">$</span> dirout <span class="fu">&lt;/&gt;</span> <span class="st">&quot;public&quot;</span>
</code></pre>
<p>Create all the directories needed to put future files into.</p><pre class="sourceCode"><code class="sourceCode">  forM_ dirs <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="kw">let</span> x&#39;   <span class="fu">=</span> T.pack x
        dir&#39; <span class="fu">=</span> T.unpack <span class="fu">$</span> T.replace oldLocation <span class="st">&quot;&quot;</span> x&#39;
    createDirectoryIfMissing <span class="kw">False</span> <span class="fu">$</span> dirout <span class="fu">&lt;/&gt;</span> dir&#39;
</code></pre>
<p>Copy all the files into the recently created directories.</p><pre class="sourceCode"><code class="sourceCode">  forM_ files <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="kw">let</span> x&#39;   <span class="fu">=</span> T.pack x
        file <span class="fu">=</span> dirout <span class="fu">&lt;/&gt;</span> (T.unpack <span class="fu">$</span> T.replace oldLocation <span class="st">&quot;&quot;</span> x&#39;)
    copyFile x file
</code></pre>
<h2 id="configuration">Configuration</h2>
<p>Default configuration <strong>options</strong>. If no arguments for these flags are specifed, it will just use the ones in <code>defaultConfig</code>.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">defaultConfig ::</span> <span class="dt">Hyakko</span>
defaultConfig <span class="fu">=</span> <span class="dt">Hyakko</span>
  { layout     <span class="fu">=</span> <span class="kw">Just</span> <span class="st">&quot;parallel&quot;</span> <span class="fu">&amp;=</span> typ <span class="st">&quot;LAYOUT&quot;</span>
              <span class="fu">&amp;=</span> help <span class="st">&quot;choose a built-in layout (parallel, linear)&quot;</span>
  , output     <span class="fu">=</span> <span class="st">&quot;docs&quot;</span>  <span class="fu">&amp;=</span> typDir
              <span class="fu">&amp;=</span> help <span class="st">&quot;use a custom output path&quot;</span>
  , css        <span class="fu">=</span> <span class="kw">Nothing</span> <span class="fu">&amp;=</span> typFile
              <span class="fu">&amp;=</span> help <span class="st">&quot;use a custom css file&quot;</span>
  , template   <span class="fu">=</span> <span class="kw">Nothing</span> <span class="fu">&amp;=</span> typFile
              <span class="fu">&amp;=</span> help <span class="st">&quot;use a custom pandoc template&quot;</span>
  , dirOrFiles <span class="fu">=</span> [] <span class="fu">&amp;=</span> args <span class="fu">&amp;=</span> typ <span class="st">&quot;FILES/DIRS&quot;</span>
  } <span class="fu">&amp;=</span> summary (<span class="st">&quot;hyakko v&quot;</span> <span class="fu">++</span> showVersion version)
</code></pre>
<p><strong>Configure</strong> this particular run of hyakko. We might use a passed-in external template, or one of the built-in <strong>layouts</strong>.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">configHyakko ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Hyakko</span>
configHyakko oldConfig datadir <span class="fu">=</span>
  <span class="kw">if</span> isNothing <span class="fu">$</span> template oldConfig <span class="kw">then</span>
    <span class="kw">let</span> dir    <span class="fu">=</span> datadir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;resources&quot;</span>
                         <span class="fu">&lt;/&gt;</span> (fromJust <span class="fu">$</span> layout oldConfig)
    <span class="kw">in</span> oldConfig { template <span class="fu">=</span> <span class="kw">Just</span> <span class="fu">$</span> dir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.html&quot;</span>
                 , css      <span class="fu">=</span> <span class="kw">Just</span> <span class="fu">$</span> dir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.css&quot;</span>
                 }
    <span class="kw">else</span>
      oldConfig { layout <span class="fu">=</span> <span class="kw">Nothing</span> }
</code></pre>
<p>Finally, using <a href="http://community.haskell.org/~ndm/cmdargs/">CmdArgs</a>, define a command line interface. Parse options and hyakko does the rest.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  opts <span class="ot">&lt;-</span> cmdArgs defaultConfig
  source <span class="ot">&lt;-</span> sources <span class="fu">$</span> dirOrFiles opts
  createDirectoryIfMissing <span class="kw">False</span> <span class="fu">$</span> output opts
  generateDocumentation opts source</code></pre>
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
