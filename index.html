<!DOCTYPE html>

<html>
<head>
  <title>Hyakko</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
    <link rel="stylesheet" media="all" href="hyakko.css" />
  </head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
                <h1 id="hyakko">Hyakko</h1>
        
              </div>

<p><strong>Hyakko</strong> is a Haskell port of <a href="http://jashkenas.github.com/docco/">docco</a>: the original quick-and-dirty documentation generate. It produces an HTML document that displays your comments intermingled with you code. All prose is passed through <a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a>, and code is passed through <a href="http://johnmacfarlane.net/highlighting-kate/">Kate</a> syntax highlighing. This page is the result of running Hyakko against its own <a href="https://github.com/sourrust/hyakko/blob/master/src/Hyakko.lhs">source file</a>.</p>
<ol style="list-style-type: decimal">
<li><p>Install Hyakko with <strong>cabal</strong>: <code>cabal update; cabal install hyakko</code></p></li>
<li><p>Run it agianst your code: <code>hyakko src/*.hs</code> or just <code>hyakko src</code> and Hyakko will search for supported files inside the directory recursively.</p></li>
</ol>
<p>There is no &quot;Step 3&quot;. This will generate an HTML page for each of the named source files, with a menu linking to the other pages, saving the whole mess into a <code>docs</code> folder — and is also configurable.</p>
<p>The <a href="https://github.com/sourrust/hyakko">Hyakko source</a> is available on GitHub, and is released under the <a href="http://opensource.org/licenses/MIT">MIT license</a>.</p>
<p>There is a <a href="http://www.haskell.org/haskellwiki/Literate_programming">&quot;literate&quot; style</a> of Haskell, only one supported at this time, but other literate styles can be added fairly easily via a <a href="https://github.com/sourrust/hyakko/blob/master/resources/languages.json">separate languages file</a>.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Hyakko.Text.Markdown</span>
<span class="kw">import </span><span class="dt">Hyakko.Text.Templates</span>
<span class="kw">import </span><span class="dt">Hyakko.Types</span>

<span class="kw">import </span><span class="dt">Data.Aeson</span> (decode&#39;, <span class="dt">Value</span>(..))
<span class="kw">import qualified</span> <span class="dt">Data.HashMap.Strict</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import </span><span class="dt">Data.ByteString.Lazy.Char8</span> (<span class="dt">ByteString</span>)
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">L</span>
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>)
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import </span><span class="dt">Data.List</span> (sort)
<span class="kw">import </span><span class="dt">Data.Maybe</span> (fromJust, isNothing)
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Data.Version</span> (showVersion)
<span class="kw">import </span><span class="dt">Control.Applicative</span> ((&lt;$&gt;))
<span class="kw">import </span><span class="dt">Control.Monad</span> (filterM, (&gt;=&gt;), forM, forM_, unless, when)
<span class="kw">import </span><span class="dt">Control.Monad.State.Strict</span>
<span class="kw">import qualified</span> <span class="dt">Text.Blaze.Html</span> <span class="kw">as</span> <span class="dt">B</span>
<span class="kw">import </span><span class="dt">Text.Blaze.Html.Renderer.Utf8</span> (renderHtml)
<span class="kw">import qualified</span> <span class="dt">Text.Highlighting.Kate</span> <span class="kw">as</span> <span class="dt">K</span>
<span class="kw">import </span><span class="dt">Text.Pandoc.Templates</span>
<span class="kw">import </span><span class="dt">Text.Regex.PCRE</span> ((=~))
<span class="kw">import </span><span class="dt">System.Directory</span> ( getDirectoryContents
                        , doesDirectoryExist
                        , doesFileExist
                        , createDirectoryIfMissing
                        , copyFile
                        )
<span class="kw">import </span><span class="dt">System.Console.Docopt.NoTH</span>
<span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)
<span class="kw">import </span><span class="dt">System.Exit</span> (exitSuccess)
<span class="kw">import </span><span class="dt">System.FilePath</span> ( takeBaseName
                       , takeExtension
                       , takeFileName
                       , (<span class="fu">&lt;/&gt;</span>)
                       , addTrailingPathSeparator
                       )
<span class="kw">import </span><span class="dt">Paths_hyakko</span> (getDataFileName, version, getDataDir)
</code></pre></div>
<h2 id="main-documentation-generation-functions">Main Documentation Generation Functions</h2>
<p>Generate the documentation for our configured source file by copyinh over static assets, reading all the source files in, splitting them up into prose+code sections, highlighting each file in the approapiate language, and printing them out in an HTML template.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">generateDocumentation ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> [FilePath] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
generateDocumentation _ [] <span class="fu">=</span>
  putStrLn <span class="st">&quot;hyakko: no files or options given (try --help)&quot;</span>
generateDocumentation opts xs <span class="fu">=</span> <span class="kw">do</span>
  dataDir <span class="ot">&lt;-</span> getDataDir
  <span class="kw">let</span> options  <span class="fu">=</span> configHyakko opts dataDir
      dirout   <span class="fu">=</span> output options
      langFile <span class="fu">=</span> languages options
  style    <span class="ot">&lt;-</span> hyakkoStyles options
  langList <span class="ot">&lt;-</span> decodeLanguageFile langFile
  T.writeFile (dirout <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.css&quot;</span>) style
  unless (isNothing <span class="fu">$</span> layout options) <span class="fu">$</span> <span class="kw">do</span>
    <span class="kw">let</span> layoutDir <span class="fu">=</span> fromJust <span class="fu">$</span> layout options
    copyDirectory options <span class="fu">$</span> dataDir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;resources&quot;</span> <span class="fu">&lt;/&gt;</span> layoutDir
                                    <span class="fu">&lt;/&gt;</span> <span class="st">&quot;public&quot;</span>
  forM_ xs <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
    code <span class="ot">&lt;-</span> T.readFile x
    <span class="kw">let</span> language  <span class="fu">=</span> getLanguage x langList
        sections  <span class="fu">=</span> parse language code
        noSects   <span class="fu">=</span> null sections
    when noSects <span class="fu">$</span>
      putStrLn <span class="fu">$</span> <span class="st">&quot;hyakko doesn&#39;t support the language extension &quot;</span>
               <span class="fu">++</span> takeExtension x
    unless noSects <span class="fu">$</span> <span class="kw">do</span>
      <span class="kw">let</span> highlighted <span class="fu">=</span> highlight language sections
          y           <span class="fu">=</span> mapSections sections highlighted
      generateHTML options x y
</code></pre></div>
<p>Given a string of source code, parse out eacg block of prose and the code that follows it — by detecting which is which, line by line — then create an individual <strong>section</strong> for it. Each section is Map with <code>docText</code> and <code>codeText</code> properties, and eventuall <code>docsHtml</code> and <code>codeHtml</code> as well.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">inSections ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Sections</span>
inSections xs r <span class="fu">=</span>
  <span class="kw">let</span> sections <span class="fu">=</span> sectionOff mempty mempty xs
  <span class="kw">in</span> map M.fromList sections

  <span class="kw">where</span><span class="ot"> save ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">Text</span>)]
        save code docs <span class="fu">=</span> [ (<span class="st">&quot;codeText&quot;</span>, code)
                         , (<span class="st">&quot;docsText&quot;</span>, docs)
                         ]

<span class="ot">        sectionOff ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> [[(<span class="dt">String</span>, <span class="dt">Text</span>)]]
        sectionOff code docs [] <span class="fu">=</span> save code docs <span class="fu">:</span> []
        sectionOff code docs (y<span class="fu">:</span>ys) <span class="fu">=</span>
          <span class="kw">let</span> line    <span class="fu">=</span> T.unpack y
              shebang <span class="fu">=</span> L.pack <span class="st">&quot;(^#![/]|^\\s*#\\{)&quot;</span>
              r&#39;      <span class="fu">=</span> L.pack <span class="fu">$</span> T.unpack r
          <span class="kw">in</span> <span class="kw">if</span> line <span class="fu">=~</span> r&#39; <span class="fu">&amp;&amp;</span> (not <span class="fu">$</span> line <span class="fu">=~</span> shebang) <span class="kw">then</span>
               handleDocs code
               <span class="kw">else</span>
                 sectionOff (code <span class="fu">&lt;&gt;</span> y <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>) docs ys

          <span class="kw">where</span> handleDocs <span class="st">&quot;&quot;</span> <span class="fu">=</span> handleHeaders code (newdocs docs) ys
                handleDocs _  <span class="fu">=</span> save code docs
                              <span class="fu">:</span> handleHeaders mempty (newdocs mempty) ys

                newdocs d <span class="fu">=</span> d <span class="fu">&lt;&gt;</span> (replace r y mempty) <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>
</code></pre></div>
<p>If there is a header markup, only for <code>---</code> and <code>===</code>, it will get its own line from the other documentation.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">                handleHeaders c d zs <span class="fu">=</span>
                  <span class="kw">if</span> T.unpack d <span class="fu">=~</span> L.pack <span class="st">&quot;^(---|===)+&quot;</span> <span class="kw">then</span>
                    save c d <span class="fu">:</span> sectionOff mempty mempty zs
                    <span class="kw">else</span>
                      sectionOff c d zs
</code></pre></div>
<p>The higher level interface for calling <code>inSections</code>. <code>parse</code> basically sanitates the file — turing literate into regular source and take out shebangs — then feed it to <code>inSections</code>, and finally return the results.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">parse ::</span> <span class="dt">Maybe</span> <span class="dt">Language</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Sections</span>
parse <span class="dt">Nothing</span> _       <span class="fu">=</span> []
parse (<span class="dt">Just</span> src) code <span class="fu">=</span>
  inSections (fromLiterate (T.lines code) <span class="fu">$</span> literate src)
             (<span class="st">&quot;^\\s*&quot;</span> <span class="fu">&lt;&gt;</span> symbol src <span class="fu">&lt;&gt;</span> <span class="st">&quot;\\s?&quot;</span>)
</code></pre></div>
<p>Transforms a literate style language file into its normal, non-literate style language. If it is normal, <code>fromLiterate</code> for returns the same list of <code>Text</code> that was passed in.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">  <span class="kw">where</span><span class="ot"> fromLiterate ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>]
        fromLiterate [] _     <span class="fu">=</span> []
        fromLiterate xs <span class="dt">False</span> <span class="fu">=</span> xs
        fromLiterate xs <span class="dt">True</span>  <span class="fu">=</span>
          <span class="kw">let</span> s  <span class="fu">=</span> symbol src
              r  <span class="fu">=</span> <span class="st">&quot;^&quot;</span> <span class="fu">&lt;&gt;</span> (fromJust <span class="fu">$</span> litSymbol src) <span class="fu">&lt;&gt;</span> <span class="st">&quot;\\s?&quot;</span>
              r1 <span class="fu">=</span> L.pack <span class="st">&quot;^\\s*$&quot;</span>
              fn <span class="fu">=</span> forM xs <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
                (ys, isText) <span class="ot">&lt;-</span> get
                <span class="kw">let</span> hasLitSymbol <span class="fu">=</span> T.unpack x <span class="fu">=~</span> (L.pack <span class="fu">$</span> T.unpack r)

                when hasLitSymbol <span class="fu">$</span>
                  put (ys <span class="fu">++</span> [replace r x mempty], <span class="dt">False</span>)
</code></pre></div>
<p>Inserts a comment symbol and a single space into the documentation line and check if the last line was code and documentation. If the previous line was code and the line is blank or has just whitespace, it returns a blank <code>Text</code> datatype; otherwise it will return just the comment symbol.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">                unless hasLitSymbol <span class="fu">$</span>
                  <span class="kw">case</span> (T.unpack x <span class="fu">=~</span> r1, isText) <span class="kw">of</span>
                    (<span class="dt">True</span>, <span class="dt">True</span>)  <span class="ot">-&gt;</span> put (ys <span class="fu">++</span> [s], <span class="dt">True</span>)
                    (<span class="dt">True</span>, <span class="dt">False</span>) <span class="ot">-&gt;</span> put (ys <span class="fu">++</span> [mempty], <span class="dt">False</span>)
                    (<span class="dt">False</span>, _)    <span class="ot">-&gt;</span> put (ys <span class="fu">++</span> [s <span class="fu">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="fu">&lt;&gt;</span> x], <span class="dt">True</span>)
          <span class="kw">in</span> fst <span class="fu">.</span> snd <span class="fu">$</span> runState fn (mempty, <span class="dt">True</span>)
</code></pre></div>
<p>Highlights the current file of code, using <strong>Kate</strong>, and outputs the the highlighted html to its caller.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">highlight ::</span> <span class="dt">Maybe</span> <span class="dt">Language</span> <span class="ot">-&gt;</span> <span class="dt">Sections</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>]
highlight language&#39; section <span class="fu">=</span>
  <span class="kw">let</span> language <span class="fu">=</span> fromJust language&#39;
      langName <span class="fu">=</span> T.unpack <span class="fu">$</span> name_ language
      input    <span class="fu">=</span> map (T.unpack <span class="fu">.</span> (<span class="fu">M.!</span> <span class="st">&quot;codeText&quot;</span>)) section
      html     <span class="fu">=</span> B.toHtml <span class="fu">.</span> K.formatHtmlBlock K.defaultFormatOpts
                          <span class="fu">.</span> K.highlightAs langName
      htmlText <span class="fu">=</span> T.pack <span class="fu">.</span> L.unpack <span class="fu">.</span> renderHtml <span class="fu">.</span> html
  <span class="kw">in</span> map htmlText input
</code></pre></div>
<p><code>mapSections</code> is used to insert the html parts of the mapped sections of text into the corresponding keys of <code>docsHtml</code> and <code>codeHtml</code>.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">mapSections ::</span> <span class="dt">Sections</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Sections</span>
mapSections section highlighted <span class="fu">=</span>
  <span class="kw">let</span> docText s  <span class="fu">=</span> toHTML <span class="fu">.</span> T.unpack <span class="fu">$</span> s <span class="fu">M.!</span> <span class="st">&quot;docsText&quot;</span>
      codeText i <span class="fu">=</span> highlighted <span class="fu">!!</span> i
      sectLength <span class="fu">=</span> (length section) <span class="fu">-</span> <span class="dv">1</span>
      intoMap x  <span class="fu">=</span> <span class="kw">let</span> sect <span class="fu">=</span> section <span class="fu">!!</span> x
                   <span class="kw">in</span> M.insert <span class="st">&quot;docsHtml&quot;</span> (docText sect) <span class="fu">$</span>
                      M.insert <span class="st">&quot;codeHtml&quot;</span> (codeText x) sect
  <span class="kw">in</span> map intoMap [<span class="dv">0</span> <span class="fu">..</span> sectLength]
</code></pre></div>
<p>Once all of the code is finished highlighting, we can generate the HTML file and write out the documentation. Pass the completed sections into the template found in <code>resources/linear/hyakko.html</code> or <code>resources/parallel/hyakko.html</code>.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">generateHTML ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Sections</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
generateHTML opts src section <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> title       <span class="fu">=</span> takeFileName src
      dest        <span class="fu">=</span> destination (output opts) src
      maybeLayout <span class="fu">=</span> layout opts
      header      <span class="fu">=</span> T.unpack <span class="fu">$</span> (section <span class="fu">!!</span> <span class="dv">0</span>) <span class="fu">M.!</span> <span class="st">&quot;docsHtml&quot;</span>
      isHeader    <span class="fu">=</span> header <span class="fu">=~</span> L.pack <span class="st">&quot;^&lt;(h\\d)&quot;</span>
      count       <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> (length section) <span class="fu">-</span> <span class="dv">1</span>]
      (h, count&#39;) <span class="fu">=</span> <span class="kw">if</span> isHeader <span class="kw">then</span>
        <span class="kw">let</span> layout&#39; <span class="fu">=</span> maybe mempty id maybeLayout
        <span class="kw">in</span> ( [(<span class="st">&quot;header&quot;</span>, header)]
           , (<span class="kw">if</span> layout&#39; <span class="fu">==</span> <span class="st">&quot;linear&quot;</span> <span class="kw">then</span> tail <span class="kw">else</span> id) count)
        <span class="kw">else</span>
          ([(<span class="st">&quot;header&quot;</span>, header)], count)
  source <span class="ot">&lt;-</span> sources <span class="fu">$</span> dirOrFiles opts
  html <span class="ot">&lt;-</span> hyakkoTemplate opts <span class="fu">.</span> varListToJSON <span class="fu">$</span> concat
    [ [(<span class="st">&quot;title&quot;</span>, <span class="kw">if</span> isHeader <span class="kw">then</span> getHeader header <span class="kw">else</span> title)]
    , h
    , cssTemplate opts
    , multiTemplate <span class="fu">$</span> length source
    , sourceTemplate opts source
    , sectionTemplate section maybeLayout count&#39;
    ]
  putStrLn <span class="fu">$</span> <span class="st">&quot;hyakko: &quot;</span> <span class="fu">++</span> src <span class="fu">++</span> <span class="st">&quot; -&gt; &quot;</span> <span class="fu">++</span> dest
  T.writeFile dest html
</code></pre></div>
<p>Small helper to yank out the header text from an html string, if there is a header at the top of the file.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">getHeader ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
getHeader htmlheader <span class="fu">=</span>
  <span class="kw">let</span> reg            <span class="fu">=</span> L.pack <span class="st">&quot;&gt;(.+)&lt;/h\\d&gt;&quot;</span>
      [(_<span class="fu">:</span>header<span class="fu">:</span>_)] <span class="fu">=</span> htmlheader <span class="fu">=~</span> reg
  <span class="kw">in</span> header
</code></pre></div>
<h2 id="helpers-setup">Helpers &amp; Setup</h2>
<p>Simpler type signatuted regex replace function.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">replace ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>
replace reg x y <span class="fu">=</span>
  <span class="kw">let</span> str        <span class="fu">=</span> T.unpack x
      reg&#39;       <span class="fu">=</span> L.pack <span class="fu">$</span> T.unpack reg
      (_, _, rp) <span class="fu">=</span> str <span class="fu">=~</span><span class="ot"> reg&#39; ::</span> (<span class="dt">String</span>, <span class="dt">String</span>, <span class="dt">String</span>)
  <span class="kw">in</span> y <span class="fu">&lt;&gt;</span> (T.pack rp)

<span class="ot">readLanguageFile ::</span> <span class="dt">IO</span> <span class="dt">ByteString</span>
readLanguageFile <span class="fu">=</span> getDataFileName <span class="st">&quot;resources/languages.json&quot;</span>
               <span class="fu">&gt;&gt;=</span> L.readFile
</code></pre></div>
<p>From a <code>languages.json</code> file, transform the data into useful list of language information inside the JSON.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">decodeLanguageFile ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Languages</span>)
decodeLanguageFile <span class="fu">=</span> L.readFile <span class="fu">&gt;=&gt;</span> return <span class="fu">.</span> decode&#39;
</code></pre></div>
<p>Search a <code>HashMap</code> of languages with file extensions as keys.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">getLanguage ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Languages</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Language</span>
getLanguage _ <span class="dt">Nothing</span>        <span class="fu">=</span> <span class="dt">Nothing</span>
getLanguage src (<span class="dt">Just</span> langs) <span class="fu">=</span> M.lookup (takeExtension src) langs
</code></pre></div>
<p>Compute the destination HTML path for an input source file path. If the source is <code>lib/example.hs</code>, the HTML will be at docs/example.html</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">destination ::</span> FilePath <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> FilePath
destination out fp <span class="fu">=</span> out <span class="fu">&lt;/&gt;</span> (takeBaseName fp) <span class="fu">++</span> <span class="st">&quot;.html&quot;</span>
</code></pre></div>
<p>The function <code>hyakkoFile</code>, used to grab the contents of either the default css and html or a custom css and html. Then move it to the output directory.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">hyakkoFile ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
hyakkoFile filetype opts <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> maybeFile <span class="fu">=</span> (<span class="kw">if</span> filetype <span class="fu">==</span> <span class="st">&quot;css&quot;</span> <span class="kw">then</span> css <span class="kw">else</span> template) opts
  <span class="kw">if</span> isNothing maybeFile <span class="kw">then</span>
    readDataFile <span class="fu">$</span> <span class="st">&quot;resources&quot;</span>
               <span class="fu">&lt;/&gt;</span> (fromJust <span class="fu">$</span> layout opts)
               <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.&quot;</span> <span class="fu">++</span> filetype
    <span class="kw">else</span>
      T.readFile <span class="fu">$</span> fromJust maybeFile

</code></pre></div>
<p>Create the template that we will use to generate the Hyakko HTML page.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">hyakkoTemplate ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
hyakkoTemplate opts var <span class="fu">=</span> <span class="kw">do</span>
  content <span class="ot">&lt;-</span> hyakkoFile <span class="st">&quot;html&quot;</span> opts
  return <span class="fu">.</span> T.pack <span class="fu">$</span> renderTemplate&#39; (T.unpack content) var
</code></pre></div>
<p>The CSS styles we'd like to apply to the documentation.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">hyakkoStyles ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
hyakkoStyles <span class="fu">=</span> hyakkoFile <span class="st">&quot;css&quot;</span>
</code></pre></div>
<p>Reads from resource path given in cabal package</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">readDataFile ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
readDataFile <span class="fu">=</span> getDataFileName <span class="fu">&gt;=&gt;</span> T.readFile
</code></pre></div>
<p>For each source file passed in as an argument, generate the documentation.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">sources ::</span> [FilePath] <span class="ot">-&gt;</span> <span class="dt">IO</span> [FilePath]
sources file <span class="fu">=</span> <span class="kw">do</span>
  files <span class="ot">&lt;-</span> forM file <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
    isDir <span class="ot">&lt;-</span> doesDirectoryExist x
    <span class="kw">if</span> isDir <span class="kw">then</span>
      fst <span class="fu">&lt;$&gt;</span> unpackDirectories x
      <span class="kw">else</span>
        return [x]
  return <span class="fu">.</span> sort <span class="fu">$</span> concat files
</code></pre></div>
<p>Turns the directory give into a list of files including all of the files in sub-directories.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">unpackDirectories ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ([FilePath], [FilePath])
unpackDirectories d <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> reg <span class="fu">=</span> L.pack <span class="st">&quot;[^(^\\.{1,2}$)]&quot;</span>
  content <span class="ot">&lt;-</span>  filter (<span class="fu">=~</span> reg) <span class="fu">&lt;$&gt;</span> getDirectoryContents d
  <span class="kw">let</span> content&#39; <span class="fu">=</span> map (d <span class="fu">&lt;/&gt;</span>) content
  files <span class="ot">&lt;-</span> filterM doesFileExist content&#39;
  subdir <span class="ot">&lt;-</span> filterM doesDirectoryExist content&#39;
  subcontent <span class="ot">&lt;-</span> fmap (\x <span class="ot">-&gt;</span> (concatMap fst x, concatMap snd x))
                     (mapM unpackDirectories subdir)
  return (files <span class="fu">++</span> fst subcontent, subdir <span class="fu">++</span> snd subcontent)

<span class="ot">copyDirectory ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
copyDirectory opts dir <span class="fu">=</span> <span class="kw">do</span>
  (files, dirs) <span class="ot">&lt;-</span> unpackDirectories dir
  dataDir       <span class="ot">&lt;-</span> getDataDir
  <span class="kw">let</span> oldLocation <span class="fu">=</span> T.pack <span class="fu">.</span> addTrailingPathSeparator <span class="fu">$</span> dataDir
                      <span class="fu">&lt;/&gt;</span> <span class="st">&quot;resources&quot;</span>
                      <span class="fu">&lt;/&gt;</span> (fromJust <span class="fu">$</span> layout opts)
      dirout      <span class="fu">=</span> output opts
  createDirectoryIfMissing <span class="dt">False</span> <span class="fu">$</span> dirout <span class="fu">&lt;/&gt;</span> <span class="st">&quot;public&quot;</span>
</code></pre></div>
<p>Create all the directories needed to put future files into.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">  forM_ dirs <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="kw">let</span> x&#39;   <span class="fu">=</span> T.pack x
        dir&#39; <span class="fu">=</span> T.unpack <span class="fu">$</span> T.replace oldLocation mempty x&#39;
    createDirectoryIfMissing <span class="dt">False</span> <span class="fu">$</span> dirout <span class="fu">&lt;/&gt;</span> dir&#39;
</code></pre></div>
<p>Copy all the files into the recently created directories.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode">  forM_ files <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="kw">let</span> x&#39;   <span class="fu">=</span> T.pack x
        file <span class="fu">=</span> dirout <span class="fu">&lt;/&gt;</span> (T.unpack <span class="fu">$</span> T.replace oldLocation mempty x&#39;)
    copyFile x file
</code></pre></div>
<p>Print information and exit hyakko when a flag is present. Mostly for <code>version</code> and <code>help</code> printing.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">whenPresentPrintAndExit ::</span> <span class="dt">Arguments</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
whenPresentPrintAndExit arguments optName string <span class="fu">=</span>
  when (arguments <span class="ot">`isPresent`</span> longOption optName) <span class="fu">$</span>
    putStrLn string <span class="fu">&gt;&gt;</span> exitSuccess
</code></pre></div>
<h2 id="configuration">Configuration</h2>
<p>Default configuration <strong>options</strong>. If no arguments for these flags are specifed, it will just use the ones in <code>defaultConfig</code>.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">defaultConfig ::</span> <span class="dt">Arguments</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Hyakko</span>
defaultConfig arguments <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> argOrDefault <span class="fu">=</span> getArgWithDefault arguments
  languageFile <span class="ot">&lt;-</span> getDataFileName <span class="fu">$</span> <span class="st">&quot;resources&quot;</span> <span class="fu">&lt;/&gt;</span> <span class="st">&quot;languages.json&quot;</span>
  return <span class="dt">Hyakko</span>
    { layout     <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="st">&quot;parallel&quot;</span> <span class="ot">`argOrDefault`</span> longOption <span class="st">&quot;layout&quot;</span>
    , output     <span class="fu">=</span> <span class="st">&quot;docs&quot;</span> <span class="ot">`argOrDefault`</span> longOption <span class="st">&quot;output&quot;</span>
    , css        <span class="fu">=</span> getArg arguments <span class="fu">$</span> longOption <span class="st">&quot;css&quot;</span>
    , template   <span class="fu">=</span> getArg arguments <span class="fu">$</span> longOption <span class="st">&quot;template&quot;</span>
    , languages  <span class="fu">=</span> languageFile <span class="ot">`argOrDefault`</span> longOption <span class="st">&quot;languages&quot;</span>
    , dirOrFiles <span class="fu">=</span> getAllArgs arguments <span class="fu">$</span> argument <span class="st">&quot;files&quot;</span>
    }
</code></pre></div>
<p><strong>Configure</strong> this particular run of hyakko. We might use a passed-in external template, or one of the built-in <strong>layouts</strong>.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">configHyakko ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Hyakko</span>
configHyakko oldConfig datadir <span class="fu">=</span>
  <span class="kw">if</span> isNothing <span class="fu">$</span> template oldConfig <span class="kw">then</span>
    <span class="kw">let</span> dir    <span class="fu">=</span> datadir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;resources&quot;</span>
                         <span class="fu">&lt;/&gt;</span> (fromJust <span class="fu">$</span> layout oldConfig)
    <span class="kw">in</span> oldConfig { template <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> dir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.html&quot;</span>
                 , css      <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> dir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.css&quot;</span>
                 }
    <span class="kw">else</span>
      oldConfig { layout <span class="fu">=</span> <span class="dt">Nothing</span> }
</code></pre></div>
<p>Using <a href="https://github.com/docopt/docopt.hs">docopt</a>, define a command line interface along with the actually usage text used for the <code>help</code> flag.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">hyakkoUsage ::</span> <span class="dt">IO</span> <span class="dt">Docopt</span>
hyakkoUsage <span class="fu">=</span> parseUsageOrExit <span class="fu">$</span> unlines
  [ <span class="st">&quot;&quot;</span>
  , <span class="st">&quot;  Usage: hyakko [options] [&lt;files&gt;...]\n&quot;</span>
  , <span class="st">&quot;  Options:\n&quot;</span>
  , <span class="st">&quot;  -h, --help              display this help message&quot;</span>
  , <span class="st">&quot;  -V, --version           display current version&quot;</span>
  , <span class="st">&quot;  -L, --languages &lt;file&gt;  use a custom languages.json&quot;</span>
  , <span class="st">&quot;  -l, --layout &lt;name&gt;     choose a built-in layout &quot;</span> <span class="fu">++</span>
                               <span class="st">&quot;(parallel, linear)&quot;</span>
  , <span class="st">&quot;  -o, --output &lt;path&gt;     use a custom output path&quot;</span>
  , <span class="st">&quot;  -c, --css &lt;file&gt;        use a custom css file&quot;</span>
  , <span class="st">&quot;  -t, --template &lt;file&gt;   use a custom pandoc template&quot;</span>
  ]
</code></pre></div>
<p>Finally, parse and handle certain flags then hyakko does the rest.</p><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  usage&#39;    <span class="ot">&lt;-</span> hyakkoUsage
  arguments <span class="ot">&lt;-</span> getArgs
  options&#39;  <span class="ot">&lt;-</span> parseArgsOrExit usage&#39; arguments
  options   <span class="ot">&lt;-</span> defaultConfig options&#39;

  whenPresentPrintAndExit options&#39; <span class="st">&quot;version&quot;</span> <span class="fu">$</span>
    <span class="st">&quot;hyakko v&quot;</span> <span class="fu">++</span> showVersion version
  whenPresentPrintAndExit options&#39; <span class="st">&quot;help&quot;</span> <span class="fu">$</span> usage usage&#39;

  source <span class="ot">&lt;-</span> sources <span class="fu">$</span> dirOrFiles options
  createDirectoryIfMissing <span class="dt">False</span> <span class="fu">$</span> output options
  generateDocumentation options source</code></pre></div>
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
