<!DOCTYPE html>

<html>
<head>
  <title>Hyakko.lhs</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
    <link rel="stylesheet" media="all" href="resources/linear/public/stylesheets/normalize.css" />
      <link rel="stylesheet" media="all" href="hyakko.css" />
    </head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
                <h1 id="hyakko">Hyakko</h1>
        
              </div>

<p><strong>Hyakko</strong> is a Haskell port of <a href="http://jashkenas.github.com/docco/">docco</a>: the original quick-and-dirty, hundred-line-line, literate-programming-style documentation generator. It produces HTML that displays your comments alongside your code. Comments are passed through <a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a> and code is passed through <a href="http://johnmacfarlane.net/highlighting-kate/">Kate</a> syntax highlighting. This page is the result of running Hyakko against its own source file.</p>
<p>If you install Hyakko, you can run it from the command-line:</p>
<pre><code>hyakko src/*.hs</code></pre>
<p>or just specify a directory and Hyakko will search for supported files inside the directory recursively.</p>
<p>Then it will generate linked HTML documentation for the named source files, saving it into a <code>docs</code> folder. The <a href="https://github.com/sourrust/hyakko">source for Hyakko</a> available on GitHub.</p>
<p>To install Hyakko</p>
<pre><code>git clone git://github.com/sourrust/hyakko.git
cd hyakko
cabal install</code></pre>
<p>or</p>
<pre><code>cabal update
cabal install hyakko</code></pre><pre class="sourceCode"><code class="sourceCode"><span class="ot">{-# LANGUAGE OverloadedStrings, DeriveDataTypeable #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> <span class="dt">Text.Markdown</span>

<span class="kw">import</span> <span class="dt">Data.Map</span> (<span class="dt">Map</span>)
<span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> (<span class="dt">ByteString</span>)
<span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">L</span>
<span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)
<span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import</span> <span class="dt">Data.List</span> (<span class="fu">sort</span>)
<span class="kw">import</span> <span class="dt">Data.Maybe</span> (fromJust, isNothing)
<span class="kw">import</span> <span class="dt">Data.Version</span> (showVersion)
<span class="kw">import</span> <span class="dt">Control.Monad</span> (filterM, (<span class="fu">&gt;=&gt;</span>), forM, forM_, unless)
<span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Blaze.Html</span> <span class="kw">as</span> <span class="dt">B</span>
<span class="kw">import</span> <span class="dt">Text.Blaze.Html.Renderer.Utf8</span> (renderHtml)
<span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Highlighting.Kate</span> <span class="kw">as</span> <span class="dt">K</span>
<span class="kw">import</span> <span class="dt">Text.Pandoc.Templates</span>
<span class="kw">import</span> <span class="dt">Text.Regex.PCRE</span> ((<span class="fu">=~</span>))
<span class="kw">import</span> <span class="dt">System.Console.CmdArgs</span>
<span class="kw">import</span> <span class="dt">System.Directory</span> ( getDirectoryContents
                        , doesDirectoryExist
                        , doesFileExist
                        , createDirectoryIfMissing
                        , copyFile
                        )
<span class="kw">import</span> <span class="dt">System.FilePath</span> ( takeBaseName
                       , takeExtension
                       , takeFileName
                       , (<span class="fu">&lt;/&gt;</span>)
                       , addTrailingPathSeparator
                       )
<span class="kw">import</span> <span class="dt">Paths_hyakko</span> (getDataFileName, version, getDataDir)
</code></pre>
<h2 id="main-documentation-generation-functions">Main Documentation Generation Functions</h2>
<p>Infix functions for easier concatenation with Text and ByteString.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">(++.) ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>
(<span class="fu">++.</span>) <span class="fu">=</span> T.append
<span class="ot">{-# INLINE (++.) #-}</span>

<span class="ot">(++*) ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
(<span class="fu">++*</span>) <span class="fu">=</span> L.append
<span class="ot">{-# INLINE (++*) #-}</span>
</code></pre>
<p>Simpler type signatuted regex replace function.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">replace ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>
replace reg x y <span class="fu">=</span>
  <span class="kw">let</span> str  <span class="fu">=</span> T.unpack x
      (_, _, rp) <span class="fu">=</span> str <span class="fu">=~</span><span class="ot"> reg ::</span> (<span class="dt">String</span>, <span class="dt">String</span>, <span class="dt">String</span>)
  <span class="kw">in</span> y <span class="fu">++.</span> (T.pack rp)
</code></pre>
<p>Generate the documentation for a source file by reading it in, splitting it up into comment/code sections, highlighting them for the appropriate language, and merging them into an HTML template.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">generateDocumentation ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> [<span class="fu">FilePath</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
generateDocumentation _ [] <span class="fu">=</span>
  <span class="fu">putStrLn</span> <span class="st">&quot;hyakko: no files or options given (try --help)&quot;</span>
generateDocumentation opts xs <span class="fu">=</span> <span class="fu">mapM_</span> generate xs
  <span class="kw">where</span><span class="ot"> generate ::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
        generate x <span class="fu">=</span> <span class="kw">do</span>
          code <span class="ot">&lt;-</span> T.readFile x
          dataDir <span class="ot">&lt;-</span> getDataDir
          <span class="kw">let</span> sections  <span class="fu">=</span> parse (getLanguage x) code
              opts&#39;     <span class="fu">=</span> configHyakko opts
          unless (isNothing <span class="fu">$</span> layout opts&#39;) <span class="fu">$</span> <span class="kw">do</span>
            <span class="kw">let</span> layoutDir <span class="fu">=</span> fromJust <span class="fu">$</span> layout opts&#39;
            copyDirectory opts&#39;<span class="fu">$</span> dataDir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;resources&quot;</span>
                                         <span class="fu">&lt;/&gt;</span> layoutDir
                                         <span class="fu">&lt;/&gt;</span> <span class="st">&quot;public&quot;</span>
          <span class="kw">if</span> <span class="fu">null</span> sections <span class="kw">then</span>
            <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot;hyakko doesn&#39;t support the language extension &quot;</span>
                     <span class="fu">++</span> takeExtension x
            <span class="kw">else</span> <span class="kw">do</span>
              <span class="kw">let</span> highlighted <span class="fu">=</span> highlight x sections
                  y           <span class="fu">=</span> mapSections sections highlighted
              generateHTML opts&#39; x y
</code></pre>
<p>Given a string of source code, parse out each comment and the code that follows it, and create an individual <strong>section</strong> for it. Sections take the form:</p>
<pre><code>[
  (&quot;docsText&quot;, ...),
  (&quot;docsHtml&quot;, ...),
  (&quot;codeText&quot;, ...),
  (&quot;codeHtml&quot;, ...)
]</code></pre><pre class="sourceCode"><code class="sourceCode"><span class="ot">inSections ::</span> [<span class="dt">Text</span>]
           <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
           <span class="ot">-&gt;</span> [<span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Text</span>]
inSections xs r <span class="fu">=</span>
  <span class="kw">let</span> sections <span class="fu">=</span> sectionOff <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span> xs
  <span class="kw">in</span> <span class="fu">map</span> M.fromList sections

  <span class="kw">where</span><span class="ot"> sectionOff ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> [[(<span class="dt">String</span>, <span class="dt">Text</span>)]]
        sectionOff code docs [] <span class="fu">=</span> [ (<span class="st">&quot;codeText&quot;</span>, code)
                                  , (<span class="st">&quot;docsText&quot;</span>, docs)
                                  ] <span class="fu">:</span> []
        sectionOff code docs (y<span class="fu">:</span>ys) <span class="fu">=</span>
          <span class="kw">if</span> T.unpack y <span class="fu">=~</span> r <span class="kw">then</span>
            handleDocs code
            <span class="kw">else</span>
              sectionOff (code <span class="fu">++.</span> y <span class="fu">++.</span> <span class="st">&quot;\n&quot;</span>) docs ys

          <span class="kw">where</span> handleDocs <span class="st">&quot;&quot;</span> <span class="fu">=</span> handleHeaders code (newdocs docs) ys
                handleDocs _  <span class="fu">=</span> [ (<span class="st">&quot;codeText&quot;</span>, code)
                                , (<span class="st">&quot;docsText&quot;</span>, docs)
                                ] <span class="fu">:</span> handleHeaders <span class="st">&quot;&quot;</span> (newdocs <span class="st">&quot;&quot;</span>) ys

                newdocs d <span class="fu">=</span> d <span class="fu">++.</span> (replace r y <span class="st">&quot;&quot;</span>) <span class="fu">++.</span> <span class="st">&quot;\n&quot;</span>
</code></pre>
<p>If there is a header markup, only for <code>---</code> and <code>===</code>, it will get its own line from the other documentation.</p><pre class="sourceCode"><code class="sourceCode">                handleHeaders c d zs <span class="fu">=</span>
                  <span class="kw">if</span> T.unpack d <span class="fu">=~</span> L.pack <span class="st">&quot;^(---|===)+&quot;</span> <span class="kw">then</span>
                    [ (<span class="st">&quot;codeText&quot;</span>, c)
                    , (<span class="st">&quot;docsText&quot;</span>, d)
                    ] <span class="fu">:</span> sectionOff <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span> zs
                    <span class="kw">else</span>
                      sectionOff c d zs

<span class="ot">parse ::</span> <span class="dt">Maybe</span> (<span class="dt">Map</span> <span class="dt">String</span> <span class="dt">ByteString</span>) <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Text</span>]
parse <span class="kw">Nothing</span> _       <span class="fu">=</span> []
parse (<span class="kw">Just</span> src) code <span class="fu">=</span>
  inSections (newlines line (M.lookup <span class="st">&quot;literate&quot;</span> src) <span class="kw">True</span>)
             (src <span class="fu">M.!</span> <span class="st">&quot;comment&quot;</span>)
  <span class="kw">where</span><span class="ot"> line ::</span> [<span class="dt">Text</span>]
        line <span class="fu">=</span> <span class="fu">filter</span> ((<span class="fu">/=</span>) <span class="st">&quot;#!&quot;</span> <span class="fu">.</span> T.take <span class="dv">2</span>) <span class="fu">$</span> T.lines code
</code></pre>
<p>Transforms a literate style language file into its normal, non-literate style language. If it is normal, <code>newlines</code> for returns the same list of <code>Text</code> that was passed in.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">        newlines ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>]
        newlines [] _ _            <span class="fu">=</span> []
        newlines xs <span class="kw">Nothing</span> _      <span class="fu">=</span> xs
        newlines (x<span class="fu">:</span>xs) lit isText <span class="fu">=</span>
          <span class="kw">let</span> s       <span class="fu">=</span> src <span class="fu">M.!</span> <span class="st">&quot;symbol&quot;</span>
              r       <span class="fu">=</span> <span class="st">&quot;^&quot;</span> <span class="fu">++*</span> (src <span class="fu">M.!</span> <span class="st">&quot;symbol2&quot;</span>) <span class="fu">++*</span> <span class="st">&quot;\\s?&quot;</span>
              r1      <span class="fu">=</span> L.pack <span class="st">&quot;^\\s*$&quot;</span>
              (x&#39;, y) <span class="fu">=</span> <span class="kw">if</span> T.unpack x <span class="fu">=~</span> r <span class="kw">then</span>
                     (replace r x <span class="st">&quot;&quot;</span>, <span class="kw">False</span>)
                     <span class="kw">else</span>
                       insert (T.unpack x <span class="fu">=~</span> r1) isText
                         ((T.pack <span class="fu">$</span> L.unpack s)  <span class="fu">++.</span> <span class="st">&quot; &quot;</span> <span class="fu">++.</span> x)
          <span class="kw">in</span> x&#39;<span class="fu">:</span> newlines xs lit y
</code></pre>
<p>Inserts a comment symbol and a single space into the documentation line and check if the last line was code and documentation. If the previous line was code and the line is blank or has just whitespace, it returns a blank <code>Text</code> datatype; otherwise it will return just the comment symbol.</p><pre class="sourceCode"><code class="sourceCode">          <span class="kw">where</span><span class="ot"> insert ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">Text</span>, <span class="dt">Bool</span>)
                insert <span class="kw">True</span> <span class="kw">True</span> _  <span class="fu">=</span> (T.pack <span class="fu">.</span> L.unpack
                                        <span class="fu">$</span> src <span class="fu">M.!</span> <span class="st">&quot;symbol&quot;</span>, <span class="kw">True</span>)
                insert <span class="kw">True</span> <span class="kw">False</span> _ <span class="fu">=</span> (<span class="st">&quot;&quot;</span>, <span class="kw">False</span>)
                insert <span class="kw">False</span> _ y    <span class="fu">=</span> (y, <span class="kw">True</span>)
</code></pre>
<p>Highlights a single chunk of Haskell code, using <strong>Kate</strong>, and runs the text of its corresponding comment through <strong>Markdown</strong>, using the Markdown translator in <strong><a href="http://johnmacfarlane.net/pandoc/">Pandoc</a></strong>.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">highlight ::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> [<span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Text</span>] <span class="ot">-&gt;</span> [<span class="dt">Text</span>]
highlight src section <span class="fu">=</span>
  <span class="kw">let</span> language <span class="fu">=</span> fromJust <span class="fu">$</span> getLanguage src
      langName <span class="fu">=</span> L.unpack <span class="fu">$</span> language <span class="fu">M.!</span> <span class="st">&quot;name&quot;</span>
      input    <span class="fu">=</span> <span class="fu">map</span> (\x <span class="ot">-&gt;</span> T.unpack <span class="fu">$</span> x <span class="fu">M.!</span> <span class="st">&quot;codeText&quot;</span>) section
      html     <span class="fu">=</span> B.toHtml <span class="fu">.</span> K.formatHtmlBlock K.defaultFormatOpts
                          <span class="fu">.</span> K.highlightAs langName
      htmlText <span class="fu">=</span> T.pack <span class="fu">.</span> L.unpack <span class="fu">.</span> renderHtml <span class="fu">.</span> html
  <span class="kw">in</span> <span class="fu">map</span> htmlText input
</code></pre>
<p><code>mapSections</code> is used to insert the html parts of the mapped sections of text into the corresponding keys of <code>docsHtml</code> and <code>codeHtml</code>.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">mapSections ::</span> [<span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Text</span>] <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> [<span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Text</span>]
mapSections section highlighted <span class="fu">=</span>
  <span class="kw">let</span> docText s  <span class="fu">=</span> toHTML <span class="fu">.</span> T.unpack <span class="fu">$</span> s <span class="fu">M.!</span> <span class="st">&quot;docsText&quot;</span>
      codeText i <span class="fu">=</span> highlighted <span class="fu">!!</span> i
      sectLength <span class="fu">=</span> (<span class="fu">length</span> section) <span class="fu">-</span> <span class="dv">1</span>
      intoMap x  <span class="fu">=</span> <span class="kw">let</span> sect <span class="fu">=</span> section <span class="fu">!!</span> x
                   <span class="kw">in</span> M.insert <span class="st">&quot;docsHtml&quot;</span> (docText sect) <span class="fu">$</span>
                      M.insert <span class="st">&quot;codeHtml&quot;</span> (codeText x) sect
  <span class="kw">in</span> <span class="fu">map</span> intoMap [<span class="dv">0</span> <span class="fu">..</span> sectLength]
</code></pre>
<p>Determine whether or not there is a <code>Jump to</code> section</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">multiTemplate ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">String</span>)]
multiTemplate <span class="dv">1</span> <span class="fu">=</span> []
multiTemplate _ <span class="fu">=</span> [(<span class="st">&quot;multi&quot;</span>, <span class="st">&quot;1&quot;</span>)]
</code></pre>
<p>Produces a list of anchor tags to different files in docs</p>
<pre><code>&lt;a class=&quot;source&quot; href=&quot;$href-link$&quot;&gt;$file-name$&lt;/a&gt;</code></pre><pre class="sourceCode"><code class="sourceCode"><span class="ot">sourceTemplate ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> [<span class="fu">FilePath</span>] <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">String</span>)]
sourceTemplate opts <span class="fu">=</span> <span class="fu">map</span> source
  <span class="kw">where</span> source x <span class="fu">=</span> (<span class="st">&quot;source&quot;</span>, <span class="fu">concat</span>
          [ <span class="st">&quot;&lt;a class=\&quot;source\&quot; href=\&quot;&quot;</span>
          , takeFileName <span class="fu">$</span> destination (output opts) x
          , <span class="st">&quot;\&quot;&gt;&quot;</span>
          , takeFileName x
          , <span class="st">&quot;&lt;/a&gt;&quot;</span>
          ])
</code></pre>
<p>Produces a list of table rows that split up code and documentation</p>
<pre><code>&lt;tr id=&quot;section-$number$&quot;&gt;
  &lt;td class=&quot;docs&quot;&gt;
    &lt;div class=&quot;pilwrap&quot;&gt;
      &lt;a class=&quot;pilcrow&quot; href=&quot;#section-$number$&quot;&gt;Î»&lt;/a&gt;
    &lt;/div&gt;
    $doc-html$
  &lt;/td&gt;
  &lt;td class=&quot;code&quot;&gt;
    $code-html$
  &lt;/td&gt;
&lt;/tr&gt;</code></pre><pre class="sourceCode"><code class="sourceCode"><span class="ot">sectionTemplate ::</span> [<span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Text</span>]
                <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span>
                <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
                <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">String</span>)]
sectionTemplate section layoutType count <span class="fu">=</span>
  <span class="kw">let</span> isLayout <span class="fu">=</span> <span class="fu">not</span> <span class="fu">$</span> isNothing layoutType
      sections <span class="fu">=</span> <span class="kw">if</span> isLayout <span class="kw">then</span> layoutFn <span class="fu">$</span> fromJust layoutType
                 <span class="kw">else</span> <span class="fu">undefined</span>
  <span class="kw">in</span> <span class="fu">map</span> sections count
  <span class="kw">where</span> layoutFn <span class="st">&quot;parallel&quot;</span> <span class="fu">=</span> parallel
        layoutFn <span class="st">&quot;linear&quot;</span>   <span class="fu">=</span> linear
        layoutFn _          <span class="fu">=</span> <span class="fu">undefined</span>
        parallel x <span class="fu">=</span>
          <span class="kw">let</span> x&#39;   <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span>
              sect <span class="fu">=</span> section <span class="fu">!!</span> x
              docsHtml <span class="fu">=</span> T.unpack <span class="fu">$</span> sect <span class="fu">M.!</span> <span class="st">&quot;docsHtml&quot;</span>
              codeHtml <span class="fu">=</span> T.unpack <span class="fu">$</span> sect <span class="fu">M.!</span> <span class="st">&quot;codeHtml&quot;</span>
              codeText <span class="fu">=</span> T.unpack <span class="fu">$</span> sect <span class="fu">M.!</span> <span class="st">&quot;codeText&quot;</span>
              header   <span class="fu">=</span> docsHtml <span class="fu">=~</span> L.pack <span class="st">&quot;^\\s*&lt;(h\\d)&quot;</span>
              isBlank  <span class="fu">=</span> T.null <span class="fu">$</span> replace <span class="st">&quot;\\s&quot;</span> (T.pack codeText) <span class="st">&quot;&quot;</span>
          <span class="kw">in</span> (<span class="st">&quot;section&quot;</span>, <span class="fu">concat</span>
             [ <span class="st">&quot;&lt;li id=\&quot;section-&quot;</span>
             , <span class="fu">show</span> x&#39;
             , <span class="st">&quot;\&quot;&gt;&lt;div class=\&quot;annotation\&quot;&gt;&quot;</span>
             , <span class="st">&quot;&lt;div class=\&quot;pilwrap&quot;</span>
             , <span class="kw">if</span> <span class="fu">null</span> header <span class="kw">then</span> <span class="st">&quot;&quot;</span> <span class="kw">else</span> <span class="st">&quot; for-&quot;</span> <span class="fu">++</span> <span class="fu">tail</span> header
             , <span class="st">&quot;\&quot;&gt;&lt;a class=\&quot;pilcrow\&quot; href=\&quot;&quot;</span>
             , <span class="fu">show</span> x&#39;
             , <span class="st">&quot;\&quot;&gt;&amp;#955;&lt;/a&gt;&lt;/div&gt;&quot;</span>
             , docsHtml
             , <span class="st">&quot;&lt;/div&gt;&quot;</span>
             , <span class="kw">if</span> isBlank <span class="kw">then</span> <span class="st">&quot;&quot;</span> <span class="kw">else</span> <span class="st">&quot;&lt;div class=\&quot;content\&quot;&gt;&quot;</span>
                 <span class="fu">++</span> codeHtml <span class="fu">++</span> <span class="st">&quot;&lt;/div&gt;&quot;</span>
             ])
        linear x <span class="fu">=</span>
          <span class="kw">let</span> sect   <span class="fu">=</span> section <span class="fu">!!</span> x
              codeText <span class="fu">=</span> T.unpack <span class="fu">$</span> sect <span class="fu">M.!</span> <span class="st">&quot;codeText&quot;</span>
              isText <span class="fu">=</span> <span class="fu">not</span> <span class="fu">$</span> <span class="fu">null</span> codeText
          <span class="kw">in</span> (<span class="st">&quot;section&quot;</span>, <span class="fu">concat</span>
             [ T.unpack <span class="fu">$</span> sect <span class="fu">M.!</span> <span class="st">&quot;docsHtml&quot;</span>
             , <span class="kw">if</span> isText <span class="kw">then</span> T.unpack <span class="fu">$</span> sect <span class="fu">M.!</span> <span class="st">&quot;codeHtml&quot;</span> <span class="kw">else</span> []
             ])

<span class="ot">cssTemplate ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">String</span>)]
cssTemplate opts <span class="fu">=</span>
  <span class="kw">let</span> maybeLayout <span class="fu">=</span> layout opts
      normalize   <span class="fu">=</span> <span class="st">&quot;public&quot;</span> <span class="fu">&lt;/&gt;</span> <span class="st">&quot;stylesheets&quot;</span> <span class="fu">&lt;/&gt;</span> <span class="st">&quot;normalize.css&quot;</span>
      otherFile   <span class="fu">=</span> <span class="kw">if</span> isNothing maybeLayout <span class="kw">then</span> ([] <span class="fu">++</span>) <span class="kw">else</span>
        ([<span class="st">&quot;resources&quot;</span> <span class="fu">&lt;/&gt;</span> fromJust maybeLayout <span class="fu">&lt;/&gt;</span> normalize] <span class="fu">++</span>)
  <span class="kw">in</span> <span class="fu">zip</span> [<span class="st">&quot;css&quot;</span>, <span class="st">&quot;css&quot;</span>] <span class="fu">$</span> otherFile [<span class="st">&quot;hyakko.css&quot;</span>]
</code></pre>
<p>Once all of the code is finished highlighting, we can generate the HTML file and write out the documentation. Pass the completed sections into the template found in <code>resources/hyakko.html</code></p><pre class="sourceCode"><code class="sourceCode"><span class="ot">generateHTML ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> [<span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
generateHTML opts src section <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> title       <span class="fu">=</span> takeFileName src
      dest        <span class="fu">=</span> destination (output opts) src
      maybeLayout <span class="fu">=</span> layout opts
      header      <span class="fu">=</span> T.unpack <span class="fu">$</span> (section <span class="fu">!!</span> <span class="dv">0</span>) <span class="fu">M.!</span> <span class="st">&quot;docsHtml&quot;</span>
      isHeader    <span class="fu">=</span> header <span class="fu">=~</span> L.pack <span class="st">&quot;^&lt;(h\\d)&quot;</span>
      count       <span class="fu">=</span> [<span class="dv">0</span> <span class="fu">..</span> (<span class="fu">length</span> section) <span class="fu">-</span> <span class="dv">1</span>]
      (h, count&#39;) <span class="fu">=</span> <span class="kw">if</span> isHeader <span class="kw">then</span>
        <span class="kw">let</span> layout&#39; <span class="fu">=</span> <span class="kw">if</span> isNothing maybeLayout <span class="kw">then</span> <span class="st">&quot;&quot;</span>
                      <span class="kw">else</span> fromJust maybeLayout
        <span class="kw">in</span> ( [(<span class="st">&quot;header&quot;</span>, header)]
           , (<span class="kw">if</span> layout&#39; <span class="fu">==</span> <span class="st">&quot;linear&quot;</span> <span class="kw">then</span> <span class="fu">tail</span> <span class="kw">else</span> <span class="fu">id</span>) count)
        <span class="kw">else</span>
          ([(<span class="st">&quot;header&quot;</span>, header)], count)
  source <span class="ot">&lt;-</span> sources <span class="fu">$</span> dirOrFiles opts
  html <span class="ot">&lt;-</span> hyakkoTemplate opts <span class="fu">$</span> <span class="fu">concat</span>
    [ [(<span class="st">&quot;title&quot;</span>, title)]
    , h
    , cssTemplate opts
    , multiTemplate <span class="fu">$</span> <span class="fu">length</span> source
    , sourceTemplate opts source
    , sectionTemplate section maybeLayout count&#39;
    ]
  <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot;hyakko: &quot;</span> <span class="fu">++</span> src <span class="fu">++</span> <span class="st">&quot; -&gt; &quot;</span> <span class="fu">++</span> dest
  T.writeFile dest html
</code></pre>
<h2 id="helpers-setup">Helpers &amp; Setup</h2>
<p>A list of the languages that Hyakko supports, mapping the file extension to the name of the Pygments lexer and the symbol that indicates a comment. To add another language to Hyakko's repertoire, add it here.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">languages ::</span> <span class="dt">Map</span> <span class="dt">String</span> (<span class="dt">Map</span> <span class="dt">String</span> <span class="dt">ByteString</span>)
languages <span class="fu">=</span>
  <span class="kw">let</span> hashSymbol <span class="fu">=</span> (<span class="st">&quot;symbol&quot;</span>, <span class="st">&quot;#&quot;</span>)
      language   <span class="fu">=</span> M.fromList [
          (<span class="st">&quot;.hs&quot;</span>, M.fromList [
            (<span class="st">&quot;name&quot;</span>, <span class="st">&quot;haskell&quot;</span>), (<span class="st">&quot;symbol&quot;</span>, <span class="st">&quot;--&quot;</span>)]),
          (<span class="st">&quot;.lhs&quot;</span>, M.fromList [
            (<span class="st">&quot;name&quot;</span>, <span class="st">&quot;haskell&quot;</span>), (<span class="st">&quot;symbol&quot;</span>, <span class="st">&quot;--&quot;</span>),
            (<span class="st">&quot;literate&quot;</span>, <span class="st">&quot;True&quot;</span>), (<span class="st">&quot;symbol2&quot;</span>, <span class="st">&quot;&gt;&quot;</span>)]),
          (<span class="st">&quot;.coffee&quot;</span>, M.fromList [
            (<span class="st">&quot;name&quot;</span>, <span class="st">&quot;coffee-script&quot;</span>), hashSymbol]),
          (<span class="st">&quot;.js&quot;</span>, M.fromList [
            (<span class="st">&quot;name&quot;</span>, <span class="st">&quot;javascript&quot;</span>), (<span class="st">&quot;symbol&quot;</span>, <span class="st">&quot;//&quot;</span>)]),
          (<span class="st">&quot;.py&quot;</span>, M.fromList [
            (<span class="st">&quot;name&quot;</span>, <span class="st">&quot;python&quot;</span>), hashSymbol]),
          (<span class="st">&quot;.rb&quot;</span>, M.fromList [
            (<span class="st">&quot;name&quot;</span>, <span class="st">&quot;ruby&quot;</span>), hashSymbol])
          ]
</code></pre>
<p>Does the line begin with a comment?</p><pre class="sourceCode"><code class="sourceCode">      hasComments symbol <span class="fu">=</span> <span class="st">&quot;^\\s*&quot;</span> <span class="fu">++*</span> symbol <span class="fu">++*</span>  <span class="st">&quot;\\s?&quot;</span>
      intoMap lang <span class="fu">=</span> M.insert <span class="st">&quot;comment&quot;</span>
                              (hasComments <span class="fu">$</span> lang <span class="fu">M.!</span> <span class="st">&quot;symbol&quot;</span>)
                              lang
</code></pre>
<p>Build out the appropriate matchers and delimiters for each language.</p><pre class="sourceCode"><code class="sourceCode"> <span class="kw">in</span> M.map intoMap language
</code></pre>
<p>Get the current language we're documenting, based on the extension.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">getLanguage ::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Map</span> <span class="dt">String</span> <span class="dt">ByteString</span>)
getLanguage src <span class="fu">=</span> M.lookup (takeExtension src) languages
</code></pre>
<p>Compute the destination HTML path for an input source file path. If the source is <code>lib/example.hs</code>, the HTML will be at docs/example.html</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">destination ::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="fu">FilePath</span>
destination out fp <span class="fu">=</span> out <span class="fu">&lt;/&gt;</span> (takeBaseName fp) <span class="fu">++</span> <span class="st">&quot;.html&quot;</span>
</code></pre>
<p>The function <code>hyakkoFile</code>, used to grab the contents of either the default css and html or a custom css and html. Then move it to the output directory.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">hyakkoFile ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
hyakkoFile filetype opts <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> maybeFile <span class="fu">=</span> (<span class="kw">if</span> filetype <span class="fu">==</span> <span class="st">&quot;css&quot;</span> <span class="kw">then</span> css <span class="kw">else</span> template) opts
  <span class="kw">if</span> isNothing maybeFile <span class="kw">then</span>
    readDataFile <span class="fu">$</span> <span class="st">&quot;resources&quot;</span>
               <span class="fu">&lt;/&gt;</span> (fromJust <span class="fu">$</span> layout opts)
               <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.&quot;</span> <span class="fu">++</span> filetype
    <span class="kw">else</span>
      T.readFile <span class="fu">$</span> fromJust maybeFile

</code></pre>
<p>Create the template that we will use to generate the Hyakko HTML page.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">hyakkoTemplate ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">String</span>)] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
hyakkoTemplate opts var <span class="fu">=</span> <span class="kw">do</span>
  content <span class="ot">&lt;-</span> hyakkoFile <span class="st">&quot;html&quot;</span> opts
  <span class="fu">return</span> <span class="fu">.</span> T.pack <span class="fu">.</span> renderTemplate var <span class="fu">$</span> T.unpack content
</code></pre>
<p>The CSS styles we'd like to apply to the documentation.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">hyakkoStyles ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
hyakkoStyles <span class="fu">=</span> hyakkoFile <span class="st">&quot;css&quot;</span>
</code></pre>
<p>Reads from resource path given in cabal package</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">readDataFile ::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span>
readDataFile <span class="fu">=</span> getDataFileName <span class="fu">&gt;=&gt;</span> T.readFile
</code></pre>
<p>For each source file passed in as an argument, generate the documentation.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">sources ::</span> [<span class="fu">FilePath</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="fu">FilePath</span>]
sources file <span class="fu">=</span> <span class="kw">do</span>
  files <span class="ot">&lt;-</span> forM file <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
    isDir <span class="ot">&lt;-</span> doesDirectoryExist x
    <span class="kw">if</span> isDir <span class="kw">then</span>
      unpackDirectories x <span class="fu">&gt;&gt;=</span> <span class="fu">return</span> <span class="fu">.</span> <span class="fu">fst</span>
      <span class="kw">else</span>
        <span class="fu">return</span> [x]
  <span class="fu">return</span> <span class="fu">.</span> <span class="fu">sort</span> <span class="fu">$</span> <span class="fu">concat</span> files
</code></pre>
<p>Turns the directory give into a list of files including all of the files in sub-directories.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">unpackDirectories ::</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ([<span class="fu">FilePath</span>], [<span class="fu">FilePath</span>])
unpackDirectories d <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> reg <span class="fu">=</span> L.pack <span class="st">&quot;[^(^\\.{1,2}$)]&quot;</span>
  content <span class="ot">&lt;-</span> getDirectoryContents d <span class="fu">&gt;&gt;=</span> <span class="fu">return</span> <span class="fu">.</span> <span class="fu">filter</span> (<span class="fu">=~</span> reg)
  <span class="kw">let</span> content&#39; <span class="fu">=</span> <span class="fu">map</span> (d <span class="fu">&lt;/&gt;</span>) content
  files <span class="ot">&lt;-</span> filterM doesFileExist content&#39;
  subdir <span class="ot">&lt;-</span> filterM doesDirectoryExist content&#39;
  subcontent <span class="ot">&lt;-</span> <span class="fu">mapM</span> unpackDirectories subdir <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span>
    <span class="fu">return</span> (<span class="fu">concatMap</span> <span class="fu">fst</span> x, <span class="fu">concatMap</span> <span class="fu">snd</span> x)
  <span class="fu">return</span> (files <span class="fu">++</span> <span class="fu">fst</span> subcontent, subdir <span class="fu">++</span> <span class="fu">snd</span> subcontent)

<span class="ot">copyDirectory ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="fu">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
copyDirectory opts dir <span class="fu">=</span> <span class="kw">do</span>
  (files, dirs) <span class="ot">&lt;-</span> unpackDirectories dir
  dataDir       <span class="ot">&lt;-</span> getDataDir
  <span class="kw">let</span> oldLocation <span class="fu">=</span> T.pack <span class="fu">.</span> addTrailingPathSeparator <span class="fu">$</span> dataDir
                      <span class="fu">&lt;/&gt;</span> <span class="st">&quot;resources&quot;</span>
                      <span class="fu">&lt;/&gt;</span> (fromJust <span class="fu">$</span> layout opts)
      dirout      <span class="fu">=</span> output opts
  createDirectoryIfMissing <span class="kw">False</span> <span class="fu">$</span> dirout <span class="fu">&lt;/&gt;</span> <span class="st">&quot;public&quot;</span>
</code></pre>
<p>Create all the directories needed to put future files into.</p><pre class="sourceCode"><code class="sourceCode">  forM_ dirs <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="kw">let</span> x&#39;   <span class="fu">=</span> T.pack x
        dir&#39; <span class="fu">=</span> T.unpack <span class="fu">$</span> T.replace oldLocation <span class="st">&quot;&quot;</span> x&#39;
    createDirectoryIfMissing <span class="kw">False</span> <span class="fu">$</span> dirout <span class="fu">&lt;/&gt;</span> dir&#39;
</code></pre>
<p>Copy all the files into the recently created directories.</p><pre class="sourceCode"><code class="sourceCode">  forM_ files <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="kw">let</span> x&#39;   <span class="fu">=</span> T.pack x
        file <span class="fu">=</span> dirout <span class="fu">&lt;/&gt;</span> (T.unpack <span class="fu">$</span> T.replace oldLocation <span class="st">&quot;&quot;</span> x&#39;)
    copyFile x file
</code></pre>
<h2 id="configuration">Configuration</h2>
<p>Data structure for command line argument parsing.</p><pre class="sourceCode"><code class="sourceCode"><span class="kw">data</span> <span class="dt">Hyakko</span> <span class="fu">=</span>
  <span class="dt">Hyakko</span> {<span class="ot"> layout     ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
         ,<span class="ot"> output     ::</span> <span class="fu">FilePath</span>
         ,<span class="ot"> css        ::</span> <span class="dt">Maybe</span> <span class="fu">FilePath</span>
         ,<span class="ot"> template   ::</span> <span class="dt">Maybe</span> <span class="fu">FilePath</span>
         ,<span class="ot"> dirOrFiles ::</span> [<span class="fu">FilePath</span>]
         } <span class="kw">deriving</span> (<span class="kw">Show</span>, <span class="dt">Data</span>, <span class="dt">Typeable</span>)
</code></pre>
<p>Default configuration <strong>options</strong>. If no arguments for these flags are specifed, it will just use the ones in <code>defaultConfig</code>.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">defaultConfig ::</span> <span class="dt">Hyakko</span>
defaultConfig <span class="fu">=</span> <span class="dt">Hyakko</span>
  { layout     <span class="fu">=</span> <span class="kw">Just</span> <span class="st">&quot;parallel&quot;</span> <span class="fu">&amp;=</span> typ <span class="st">&quot;LAYOUT&quot;</span>
              <span class="fu">&amp;=</span> help <span class="st">&quot;choose a built-in layout (parallel, linear)&quot;</span>
  , output     <span class="fu">=</span> <span class="st">&quot;docs&quot;</span>  <span class="fu">&amp;=</span> typDir
              <span class="fu">&amp;=</span> help <span class="st">&quot;use a custom output path&quot;</span>
  , css        <span class="fu">=</span> <span class="kw">Nothing</span> <span class="fu">&amp;=</span> typFile
              <span class="fu">&amp;=</span> help <span class="st">&quot;use a custom css file&quot;</span>
  , template   <span class="fu">=</span> <span class="kw">Nothing</span> <span class="fu">&amp;=</span> typFile
              <span class="fu">&amp;=</span> help <span class="st">&quot;use a custom pandoc template&quot;</span>
  , dirOrFiles <span class="fu">=</span> [] <span class="fu">&amp;=</span> args <span class="fu">&amp;=</span> typ <span class="st">&quot;FILES/DIRS&quot;</span>
  } <span class="fu">&amp;=</span> summary (<span class="st">&quot;hyakko v&quot;</span> <span class="fu">++</span> showVersion version)
</code></pre>
<p><strong>Configure</strong> this particular run of hyakko. We might use a passed-in external template, or one of the built-in <strong>layouts</strong>.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">configHyakko ::</span> <span class="dt">Hyakko</span> <span class="ot">-&gt;</span> <span class="dt">Hyakko</span>
configHyakko oldConfig <span class="fu">=</span>
  <span class="kw">if</span> isNothing <span class="fu">$</span> template oldConfig <span class="kw">then</span>
    <span class="kw">let</span> dir    <span class="fu">=</span> <span class="st">&quot;resources&quot;</span> <span class="fu">&lt;/&gt;</span> (fromJust <span class="fu">$</span> layout oldConfig)
    <span class="kw">in</span> oldConfig { template <span class="fu">=</span> <span class="kw">Just</span> <span class="fu">$</span> dir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.html&quot;</span>
                 , css      <span class="fu">=</span> <span class="kw">Just</span> <span class="fu">$</span> dir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.css&quot;</span>
                 }
    <span class="kw">else</span>
      oldConfig { layout <span class="fu">=</span> <span class="kw">Nothing</span> }
</code></pre>
<p>Run the script.</p><pre class="sourceCode"><code class="sourceCode"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  opts <span class="ot">&lt;-</span> cmdArgs defaultConfig
  style <span class="ot">&lt;-</span> hyakkoStyles opts
  source <span class="ot">&lt;-</span> sources <span class="fu">$</span> dirOrFiles opts
  <span class="kw">let</span> dirout <span class="fu">=</span> output opts
  createDirectoryIfMissing <span class="kw">False</span> dirout
  T.writeFile (dirout <span class="fu">&lt;/&gt;</span> <span class="st">&quot;hyakko.css&quot;</span>) style
  generateDocumentation opts source</code></pre>
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
